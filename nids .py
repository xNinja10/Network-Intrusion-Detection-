# -*- coding: utf-8 -*-
"""Python Network Intrusion Detection System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tmEXuBxWGW_97Da3uTnRqaQNmtpSnFaY
"""

#!/usr/bin/env python3

import argparse
import sys
from scapy.all import sniff, TCP, IP, Raw
from datetime import datetime
import logging

# --- Configuration ---
# Configure logging to file and console
LOG_FILE = "nids_alerts.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler(sys.stdout)
    ]
)

# --- Threat Signatures ---
# A simple dictionary of signatures to detect.
# In a real-world scenario, these would be more complex and loaded from a file.
THREAT_SIGNATURES = {
    # Rule Name: (Layer, Field, Signature Value)
    "Potential SQL Injection Attempt": (Raw, "load", b"1' OR '1'='1'"),
    "Potential XSS Attempt": (Raw, "load", b"<script>"),
    "Nmap Xmas Scan": (TCP, "flags", "FPU"),  # FIN, PSH, URG flags set
    "Nmap Null Scan": (TCP, "flags", ""),      # No flags set
    "Nikto User-Agent": (Raw, "load", b"Nikto"),
    "Shellshock Exploit Attempt": (Raw, "load", b"() { :;};"),
    "Suspicious Dir Traversal": (Raw, "load", b"../../.."),
}

# --- Detection Engine ---
def packet_analyzer(packet):
    """
    Analyzes each packet against a set of predefined threat signatures.
    """
    # Check for IP layer
    if packet.haslayer(IP):
        ip_src = packet[IP].src
        ip_dst = packet[IP].dst

        # Check for TCP layer for flag-based scans
        if packet.haslayer(TCP):
            tcp_sport = packet[TCP].sport
            tcp_dport = packet[TCP].dport
            tcp_flags = packet[TCP].flags

            for name, (layer, field, sig) in THREAT_SIGNATURES.items():
                if layer == TCP and field == "flags":
                    if tcp_flags == sig:
                        log_alert(name, ip_src, ip_dst, f"TCP Flags: {tcp_flags}", packet)

        # Check for Raw layer (payload) for payload-based signatures
        if packet.haslayer(Raw):
            payload = packet[Raw].load
            for name, (layer, field, sig) in THREAT_SIGNATURES.items():
                if layer == Raw and field == "load":
                    if sig in payload:
                        # Try to decode for cleaner logging, otherwise show raw bytes
                        try:
                            decoded_payload = payload.decode('utf-8', 'ignore')
                        except Exception:
                            decoded_payload = str(payload)
                        log_alert(name, ip_src, ip_dst, f"Payload snippet: {decoded_payload[:100]}", packet)


# --- Alerting Module ---
def log_alert(rule_name, src_ip, dst_ip, details, packet):
    """
    Logs a detected threat to the console and a log file.
    """
    message = (
        f"ALERT! Threat Detected: '{rule_name}' | "
        f"Source: {src_ip} -> Destination: {dst_ip} | "
        f"Details: {details}"
    )
    logging.warning(message)
    # You could add more actions here, like sending an email or blocking an IP.


# --- Main Sniffer Function ---
def start_sniffer(interface):
    """
    Starts the packet sniffer on the specified network interface.
    """
    if not interface:
        logging.error("No network interface specified. Use -i <interface>.")
        sys.exit(1)

    try:
        logging.info(f"Starting Network Intrusion Detection System on interface '{interface}'...")
        logging.info(f"Alerts will be logged to '{LOG_FILE}'.")
        logging.info("Press Ctrl+C to stop.")
        # The 'prn' argument specifies the callback function to be executed for each packet
        sniff(iface=interface, prn=packet_analyzer, store=0)
    except PermissionError:
        logging.error("Permission denied. You need to run this script as root (or with sudo).")
        sys.exit(1)
    except OSError as e:
        logging.error(f"Error starting sniffer on interface '{interface}': {e}")
        logging.error("Please make sure the interface exists and is up. You can check with 'ifconfig' or 'ip a'.")
        sys.exit(1)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        sys.exit(1)


# --- Entry Point ---
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="A simple Python-based Network Intrusion Detection System (NIDS).",
        epilog="Example: sudo python nids.py -i eth0"
    )
    parser.add_argument(
        "-i", "--interface",
        help="Network interface to sniff on (e.g., eth0, wlan0, en0)."
    )
    args = parser.parse_args()

    try:
        start_sniffer(args.interface)
    except KeyboardInterrupt:
        logging.info("\nSniffer stopped by user. Exiting.")
        sys.exit(0)